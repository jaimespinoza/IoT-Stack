###############################################################################
#  INPUT MQTT
###############################################################################
[[inputs.mqtt_consumer]]
  servers   = ["tcp://MQTT_HOST:MQTT_PORT"]
  topics    = ["application/+/device/+/event/up"]
  username  = "MQTT_USER"
  password  = "MQTT_PASSWORD"
  qos       = 1
  persistent_session = true
  client_id = "telegraf_uplink_processor"
  data_format = "json"


###############################################################################
#  SCRIPT 
###############################################################################
[[processors.starlark]]
  namepass = ["mqtt_consumer"]
  source = '''
def apply(metric):
    import json,time

    raw = metric.get_string("payload")
    if not raw:
        return None

    try:
        p = json.loads(raw)
    except:
        return None

    if "object" not in p:
        return None

    fields = {}
    tags = {}

    def esc(v):
        return str(v).trim()

    # timestamp desde p.time
    try:
        ts = int(time.mktime(time.strptime(p.get("time"), "%Y-%m-%dT%H:%M:%SZ")))
        metric.time = ts * 1000000000
    except:
        pass

    # tags
    app = p.get("deviceInfo", {}).get("applicationName", "unknown")
    tags["application"] = esc(app)
    tags["deviceName"] = esc(p.get("deviceInfo", {}).get("deviceName", ""))
    tags["devEUI"] = esc(p.get("deviceInfo", {}).get("devEui", p.get("devEUI","")))

    # measurement = nombre de la aplicacion
    metric.name = esc(app)

    # procesamiento de object{} igual que NodeRed
    for k,v in p["object"].items():
        if v in ["True","true"]: v = 1
        elif v in ["False","false"]: v = 0
        elif v == "LOW": v = 0
        elif v == "HIGH": v = 1
        else:
            # intentar parsear como numero
            try:
                n = float(v)
                v = n
            except:
                # conservar strings que no sean numericos
                fields[k] = v
                continue

        fields[k] = v

    # aplicar tags y fields
    for k,v in tags.items():
        metric.tags[k] = v

    for k,v in fields.items():
        metric.fields[k] = v

    return metric
'''


###############################################################################
#  OUTPUT A INFLUXDB CLOUD
###############################################################################
[agent]
  metric_batch_size = 2000
  metric_buffer_limit = 100000     # 100k m√©tricas
  flush_interval = "10s"
  flush_jitter = "5s"              # Ayuda en reconexiones masivas

[[outputs.influxdb_v2]]
  urls     = ["https://INFLUX_URL"]
  token    = "INFLUX_TOKEN"
  organization = "INFLUX_ORG"
  bucket       = "INFLUX_BUCKET"
